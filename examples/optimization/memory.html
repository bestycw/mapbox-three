<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MapboxThree - Memory Management Example</title>
    <script src='https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.js'></script>
    <link href='https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.css' rel='stylesheet' />
    <style>
        body { margin: 0; }
        #map { width: 100vw; height: 100vh; }
        .panel {
            position: fixed;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 10px;
            font-family: 'Arial', sans-serif;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        #info {
            top: 20px;
            left: 20px;
            max-width: 400px;
        }
        #controls {
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        #metrics {
            bottom: 20px;
            left: 20px;
            min-width: 350px;
        }
        .metric-group {
            margin: 15px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            border-left: 4px solid #4CAF50;
        }
        .metric-title {
            color: #4CAF50;
            font-weight: bold;
        }
        .metric-value {
            margin-left: 10px;
            color: #ddd;
        }
        button {
            padding: 10px 15px;
            background: linear-gradient(145deg, #4CAF50, #45a049);
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            text-transform: uppercase;
            font-size: 0.9em;
            letter-spacing: 0.5px;
        }
        button:hover {
            background: linear-gradient(145deg, #45a049, #3d8b40);
            transform: translateY(-1px);
        }
        .warning {
            color: #FFC107;
        }
        .critical {
            color: #FF5722;
        }
        .chart-container {
            height: 60px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            overflow: hidden;
            margin: 10px 0;
            position: relative;
        }
        .memory-bar {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #81C784);
            width: 0%;
            transition: width 0.5s ease;
        }
        .threshold-line {
            position: absolute;
            height: 100%;
            width: 2px;
            top: 0;
            transition: left 0.5s ease;
        }
        .warning-line {
            background: #FFC107;
        }
        .critical-line {
            background: #FF5722;
        }
        .test-group {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
        }
        select {
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            margin-left: 10px;
            font-size: 0.9em;
        }
        #stressTest {
            background: linear-gradient(145deg, #f44336, #d32f2f);
        }
        #stressTest:hover {
            background: linear-gradient(145deg, #d32f2f, #b71c1c);
        }
        .test-progress {
            height: 2px;
            background: #f44336;
            width: 0%;
            transition: width 0.3s;
            margin-top: 5px;
        }
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100%);
            padding: 12px 24px;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s ease;
        }
        .notification.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }
        .notification.info {
            background: linear-gradient(145deg, #2196F3, #1976D2);
        }
        .notification.warning {
            background: linear-gradient(145deg, #FFC107, #FFA000);
        }
        .notification.critical {
            background: linear-gradient(145deg, #f44336, #d32f2f);
        }
        .notification.success {
            background: linear-gradient(145deg, #4CAF50, #388E3C);
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div id="info" class="panel">
        <h3>Memory Management Demo</h3>
        <p>Demonstrates memory management and optimization of Three.js resources</p>
        <div class="metric-group">
            <div class="metric-title">Memory Usage</div>
            <div class="chart-container">
                <div class="memory-bar"></div>
                <div class="threshold-line warning-line"></div>
                <div class="threshold-line critical-line"></div>
            </div>
            <div>Used: <span id="memoryUsage" class="metric-value">0 MB</span></div>
            <div>Limit: <span id="memoryLimit" class="metric-value">64 MB</span></div>
        </div>
    </div>
    <div id="controls" class="panel">
        <div class="test-group">
            <button id="stressTest">Stress Test</button>
            <select id="testType">
                <option value="rapid">Rapid Fill</option>
                <option value="burst">Burst Fill</option>
                <option value="mixed">Mixed Resources</option>
            </select>
        </div>
        <button id="addGeometry">Add Geometry</button>
        <button id="addTexture">Add Texture</button>
        <button id="addMaterial">Add Material</button>
        <button id="cleanup">Manual Cleanup</button>
        <button id="clearAll">Clear All</button>
    </div>
    <div id="metrics" class="panel">
        <div class="metric-group">
            <div class="metric-title">Resource Statistics</div>
            <div>Geometries: <span id="geometryCount" class="metric-value">0</span></div>
            <div>Textures: <span id="textureCount" class="metric-value">0</span></div>
            <div>Materials: <span id="materialCount" class="metric-value">0</span></div>
            <div>Shaders: <span id="programCount" class="metric-value">0</span></div>
        </div>
        <div class="metric-group">
            <div class="metric-title">Cache Status</div>
            <div>Cached Resources: <span id="cachedCount" class="metric-value">0</span></div>
            <div>Last Cleanup: <span id="lastCleanup" class="metric-value">-</span></div>
        </div>
    </div>

    <script type="module">
        import { MapboxThree } from '../../src/core/MapboxThree.ts';
        import * as THREE from 'three';
        import { config as defaultConfig } from '../config.js';

        let mapboxThree;
        let memoryManager;
        const objects = new Set();
        
        const config = {
            mapbox: {
                container: 'map',
                style: 'mapbox://styles/mapbox/dark-v11',
                accessToken: defaultConfig.accessToken,
                center: [-74.5, 40],
                zoom: 15,
                pitch: 45
            },
            three: {
                autoRender: false
            },
            optimization: {
                memoryManager: {
                    enabled: true,
                    maxCacheSize: 512,
                    cleanupInterval: 5000,
                    disposalStrategy: 'lru',
                    autoCleanup: true,
                    warningThreshold: 300,
                    criticalThreshold: 400
                }
            }
        };

        async function init() {
            mapboxThree = new MapboxThree(config);
            await mapboxThree.init();
            
            const optimizationManager = mapboxThree.getOptimizationManager();
            memoryManager = optimizationManager.getStrategy('memory');
            
            if (!memoryManager) {
                console.error('Memory strategy not initialized');
                return;
            }
            
            setupEventListeners();
            setupMemoryMonitoring();
            animate();
        }

        function createRandomGeometry() {
            const geometries = [
                () => new THREE.BoxGeometry(20, 20, 20, 64, 64, 64),
                () => new THREE.SphereGeometry(15, 128, 128),
                () => new THREE.TorusGeometry(10, 3, 64, 64),
                () => new THREE.CylinderGeometry(5, 5, 20, 64, 64),
                () => new THREE.TorusKnotGeometry(10, 3, 128, 32),
                () => new THREE.IcosahedronGeometry(10, 4)
            ];
            return geometries[Math.floor(Math.random() * geometries.length)]();
        }

        function createRandomTexture() {
            const sizes = [512, 1024, 2048];
            const size = sizes[Math.floor(Math.random() * sizes.length)];
            const data = new Uint8Array(size * size * 4);
            
            for (let i = 0; i < size; i++) {
                for (let j = 0; j < size; j++) {
                    const idx = (i * size + j) * 4;
                    const pattern = Math.sin(i * 0.1) * Math.cos(j * 0.1) * 128 + 128;
                    data[idx] = pattern * Math.random();
                    data[idx + 1] = pattern * Math.random();
                    data[idx + 2] = pattern * Math.random();
                    data[idx + 3] = 255;
                }
            }
            
            const texture = new THREE.DataTexture(data, size, size);
            texture.needsUpdate = true;
            return texture;
        }

        function createRandomMaterial(texture) {
            const materials = [
                () => new THREE.MeshBasicMaterial({ 
                    color: Math.random() * 0xffffff,
                    map: texture
                }),
                () => new THREE.MeshPhongMaterial({ 
                    color: Math.random() * 0xffffff,
                    specular: 0x444444,
                    shininess: 30,
                    map: texture
                }),
                () => new THREE.MeshStandardMaterial({ 
                    color: Math.random() * 0xffffff,
                    roughness: Math.random(),
                    metalness: Math.random(),
                    map: texture
                })
            ];
            return materials[Math.floor(Math.random() * materials.length)]();
        }

        function addObject(type) {
            const key = `${type}_${Date.now()}`;
            const position = [
                -74.5 + (Math.random() - 0.5) * 0.01,
                40 + (Math.random() - 0.5) * 0.01,
                50 + Math.random() * 100
            ];

            switch (type) {
                case 'geometry': {
                    const geometry = createRandomGeometry();
                    memoryManager.cacheResource(key, geometry, 'geometry');
                    const material = new THREE.MeshPhongMaterial({ 
                        color: Math.random() * 0xffffff,
                        wireframe: true
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    mapboxThree.add(mesh, {}, { coordinates: position });
                    objects.add(mesh);
                    break;
                }
                case 'texture': {
                    const texture = createRandomTexture();
                    memoryManager.cacheResource(key, texture, 'texture');
                    const geometry = new THREE.PlaneGeometry(20, 20);
                    const material = new THREE.MeshBasicMaterial({ map: texture });
                    const mesh = new THREE.Mesh(geometry, material);
                    mapboxThree.add(mesh, {}, { coordinates: position });
                    objects.add(mesh);
                    break;
                }
                case 'material': {
                    const texture = createRandomTexture();
                    const material = createRandomMaterial(texture);
                    memoryManager.cacheResource(key, material, 'material');
                    const geometry = new THREE.BoxGeometry(20, 20, 20);
                    const mesh = new THREE.Mesh(geometry, material);
                    mapboxThree.add(mesh, {}, { coordinates: position });
                    objects.add(mesh);
                    break;
                }
            }
            
            updateMetrics();
        }

        function updateMetrics() {
            const stats = memoryManager.getMemoryStats();
            document.getElementById('geometryCount').textContent = stats.geometries;
            document.getElementById('textureCount').textContent = stats.textures;
            document.getElementById('materialCount').textContent = stats.materials;
            document.getElementById('programCount').textContent = stats.programs;

            document.getElementById('memoryUsage').textContent = 
                `${(stats.totalMemory / (1024 * 1024)).toFixed(2)} MB`;
            document.getElementById('memoryLimit').textContent = 
                `${config.optimization.memoryManager.maxCacheSize} MB`;

            // Update memory bar
            const memoryPercent = (stats.totalMemory / (config.optimization.memoryManager.maxCacheSize * 1024 * 1024)) * 100;
            document.querySelector('.memory-bar').style.width = `${memoryPercent}%`;

            // Update warning and critical lines
            const warningPercent = (config.optimization.memoryManager.warningThreshold / config.optimization.memoryManager.maxCacheSize) * 100;
            const criticalPercent = (config.optimization.memoryManager.criticalThreshold / config.optimization.memoryManager.maxCacheSize) * 100;
            document.querySelector('.warning-line').style.left = `${warningPercent}%`;
            document.querySelector('.critical-line').style.left = `${criticalPercent}%`;

            // Update status classes
            const memoryUsage = document.getElementById('memoryUsage');
            memoryUsage.className = 'metric-value';
            if (stats.totalMemory / (1024 * 1024) > config.optimization.memoryManager.criticalThreshold) {
                memoryUsage.classList.add('critical');
            } else if (stats.totalMemory / (1024 * 1024) > config.optimization.memoryManager.warningThreshold) {
                memoryUsage.classList.add('warning');
            }
        }

        function setupMemoryMonitoring() {
            memoryManager.setWarningCallback((stats) => {
                console.warn('Memory warning:', stats);
                document.getElementById('info').classList.add('warning');
                showNotification('Warning: Memory usage approaching threshold, automatic cleanup imminent', 'warning');
            });
            
            memoryManager.setCriticalCallback((stats) => {
                console.error('Critical memory usage:', stats);
                document.getElementById('info').classList.add('critical');
                showNotification('Alert: Critical memory usage detected, performing emergency cleanup', 'critical');
                memoryManager.optimizeMemory();
            });

            memoryManager.on('cleaned', () => {
                showNotification('Automatic cleanup completed', 'success');
                document.getElementById('info').classList.remove('warning', 'critical');
                updateMetrics();
            });
        }

        // 添加通知系统
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.textContent = message;
            document.body.appendChild(notification);

            // 添加动画
            setTimeout(() => notification.classList.add('show'), 10);
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // 添加通知样式
        const style = document.createElement('style');
        style.textContent = `
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(-100%);
            padding: 12px 24px;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            z-index: 1000;
            opacity: 0;
            transition: all 0.3s ease;
        }

        .notification.show {
            transform: translateX(-50%) translateY(0);
            opacity: 1;
        }

        .notification.info {
            background: linear-gradient(145deg, #2196F3, #1976D2);
        }

        .notification.warning {
            background: linear-gradient(145deg, #FFC107, #FFA000);
        }

        .notification.critical {
            background: linear-gradient(145deg, #f44336, #d32f2f);
        }

        .notification.success {
            background: linear-gradient(145deg, #4CAF50, #388E3C);
        }
        `;
        document.head.appendChild(style);

        function setupEventListeners() {
            document.getElementById('addGeometry').addEventListener('click', () => {
                addObject('geometry');
            });
            
            document.getElementById('addTexture').addEventListener('click', () => {
                addObject('texture');
            });
            
            document.getElementById('addMaterial').addEventListener('click', () => {
                addObject('material');
            });
            
            document.getElementById('cleanup').addEventListener('click', () => {
                memoryManager.optimizeMemory();
                updateMetrics();
            });
            
            document.getElementById('clearAll').addEventListener('click', () => {
                if (memoryManager) {
                    // 清空objects集合
                    objects.clear();
                    memoryManager.clear();
                    updateMetrics();
                    showNotification('All resources cleared', 'success');
                }
            });
            
            document.getElementById('stressTest').addEventListener('click', () => {
                const type = document.getElementById('testType').value;
                runStressTest(type);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            mapboxThree.render();
            
            // 旋转所有对象
            objects.forEach(obj => {
                obj.rotation.x += 0.01;
                obj.rotation.y += 0.01;
            });
            
            updateMetrics();
        }

        // 压力测试配置
        const STRESS_TEST_CONFIG = {
            rapid: {
                batchSize: 10,
                interval: 200,
                totalBatches: 20
            },
            burst: {
                batchSize: 50,
                interval: 2000,
                burstCount: 6
            },
            mixed: {
                geometryCount: 80,
                textureSize: 512,
                materialCount: 40
            }
        };

        /**
         * 执行压力测试
         */
        async function runStressTest(type) {
            const button = document.getElementById('stressTest');
            button.disabled = true;
            
            // 添加进度条
            const progress = document.createElement('div');
            progress.className = 'test-progress';
            button.parentElement.appendChild(progress);
            
            try {
                switch(type) {
                    case 'rapid':
                        await rapidFillTest(progress);
                        break;
                    case 'burst':
                        await burstFillTest(progress);
                        break;
                    case 'mixed':
                        await mixedResourceTest(progress);
                        break;
                }
            } finally {
                button.disabled = false;
                progress.remove();
            }
        }

        /**
         * 快速填充测试
         */
        async function rapidFillTest(progressBar) {
            const config = STRESS_TEST_CONFIG.rapid;
            let completedBatches = 0;

            for (let i = 0; i < config.totalBatches; i++) {
                await new Promise(resolve => setTimeout(resolve, config.interval));
                
                for (let j = 0; j < config.batchSize; j++) {
                    addObject(Math.random() < 0.5 ? 'geometry' : 'texture');
                }
                
                completedBatches++;
                progressBar.style.width = 
                    `${(completedBatches / config.totalBatches) * 100}%`;
            }
        }

        /**
         * 突发填充测试
         */
        async function burstFillTest(progressBar) {
            const config = STRESS_TEST_CONFIG.burst;
            
            for (let i = 0; i < config.burstCount; i++) {
                await new Promise(resolve => setTimeout(resolve, config.interval));
                
                for (let j = 0; j < config.batchSize; j++) {
                    addObject('material');
                }
                
                progressBar.style.width = `${((i + 1) / config.burstCount) * 100}%`;
            }
        }

        /**
         * 混合资源测试
         */
        async function mixedResourceTest(progressBar) {
            const config = STRESS_TEST_CONFIG.mixed;
            let progress = 0;
            
            // 创建大量几何体
            for (let i = 0; i < config.geometryCount; i++) {
                addObject('geometry');
                progress = (i / config.geometryCount) * 33;
                progressBar.style.width = `${progress}%`;
            }
            
            // 创建大尺寸纹理
            for (let i = 0; i < 10; i++) {
                const texture = createRandomTexture(config.textureSize);
                memoryManager.cacheTexture(`large_texture_${i}`, texture);
                progress = 33 + (i / 10) * 33;
                progressBar.style.width = `${progress}%`;
            }
            
            // 创建复杂材质
            for (let i = 0; i < config.materialCount; i++) {
                addObject('material');
                progress = 66 + (i / config.materialCount) * 34;
                progressBar.style.width = `${progress}%`;
            }
        }

        init();
    </script>
</body>
</html> 